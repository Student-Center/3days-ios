// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// 3days API 명세서
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// SMS 인증 요청
    ///
    /// - 회원 가입 또는 로그인 토큰 발급을 위한 SMS 인증을 요청합니다.
    ///
    ///
    /// - Remark: HTTP `POST /users/verifications`.
    /// - Remark: Generated from `#/paths//users/verifications/post(requestVerification)`.
    public func requestVerification(_ input: Operations.requestVerification.Input) async throws -> Operations.requestVerification.Output {
        try await client.send(
            input: input,
            forOperation: Operations.requestVerification.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/users/verifications",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.requestVerification.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.requestVerification.Output.Created.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    return .badRequest(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// SMS 인증 코드 확인
    ///
    /// - SMS 인증 요청 시 발급된 verificationId와 함께 인증 코드를 입력하여 인증을 완료합니다.
    /// - 새 사용자의 경우 회원 가입을 위한 registerToken을 발급합니다.
    /// - 기존 사용자의 경우 로그인을 위한 accessToken과 refreshToken을 발급합니다.
    ///
    ///
    /// - Remark: HTTP `PUT /users/verifications/{verificationId}`.
    /// - Remark: Generated from `#/paths//users/verifications/{verificationId}/put(verifyCode)`.
    public func verifyCode(_ input: Operations.verifyCode.Input) async throws -> Operations.verifyCode.Output {
        try await client.send(
            input: input,
            forOperation: Operations.verifyCode.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/users/verifications/{}",
                    parameters: [
                        input.path.verificationId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.verifyCode.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.verifyCode.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 회원 가입
    ///
    /// - SMS 인증 시 발급된 registerToken을 이용하여 회원 가입을 완료합니다.
    /// - 회원 가입 완료 시 accessToken과 refreshToken을 발급합니다.
    ///
    ///
    /// - Remark: HTTP `POST /users`.
    /// - Remark: Generated from `#/paths//users/post(registerUser)`.
    public func registerUser(_ input: Operations.registerUser.Input) async throws -> Operations.registerUser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.registerUser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let headers: Operations.registerUser.Output.Created.Headers = .init(Location: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Location",
                        as: Swift.String.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.registerUser.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TokenResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 409:
                    return .conflict(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
    /// 액세스 토큰 갱신
    ///
    /// - 리프레시 토큰을 사용하여 새로운 액세스 토큰을 발급받습니다.
    ///
    ///
    /// - Remark: HTTP `POST /users/token/refresh`.
    /// - Remark: Generated from `#/paths//users/token/refresh/post(refreshToken)`.
    public func refreshToken(_ input: Operations.refreshToken.Input) async throws -> Operations.refreshToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.refreshToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/users/token/refresh",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.refreshToken.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TokenResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init()
                    )
                }
            }
        )
    }
}
